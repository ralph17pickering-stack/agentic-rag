# File Metadata Editing

⚠️ **Medium** — Two layers (backend PATCH endpoint + frontend modal), but well-contained. No schema migration needed.

## Goal

Allow users to edit the four LLM-extracted metadata fields (title, summary, topics, document_date) for any document via an edit modal in the Documents UI.

---

## Task 1 — Backend: `DocumentUpdateRequest` model

**File:** `backend/app/models/documents.py`

Add a new Pydantic model with all fields optional:

```python
class DocumentUpdateRequest(BaseModel):
    title: str | None = None
    summary: str | None = None
    topics: list[str] | None = None
    document_date: str | None = None  # ISO date string YYYY-MM-DD or None
```

**Validation:** Model instantiates without error; all fields optional.

---

## Task 2 — Backend: `PATCH /api/documents/{document_id}` endpoint

**File:** `backend/app/routers/documents.py`

Add a PATCH route after the GET list route. Only update non-`None` fields in the payload (so omitting a field leaves it unchanged). Return the updated `DocumentResponse`.

```python
@router.patch("/{document_id}", response_model=DocumentResponse)
async def update_document_metadata(
    document_id: str,
    body: DocumentUpdateRequest,
    user: dict = Depends(get_current_user),
):
    sb = get_supabase_client(user["token"])
    # Verify ownership (RLS handles this, but 404 on miss is friendlier)
    existing = sb.table("documents").select("*").eq("id", document_id).execute()
    if not existing.data:
        raise HTTPException(status_code=404, detail="Document not found")

    updates = body.model_dump(exclude_none=True)
    if not updates:
        return existing.data[0]

    result = sb.table("documents").update(updates).eq("id", document_id).execute()
    return result.data[0]
```

**Import:** Add `DocumentUpdateRequest` to the import from `app.models.documents`.

**Validation:** `curl -X PATCH http://localhost:8001/api/documents/<id> -H "Authorization: Bearer <token>" -H "Content-Type: application/json" -d '{"title":"New Title"}'` returns 200 with updated document. Unauthenticated request returns 401. Non-existent ID returns 404.

---

## Task 3 — Frontend: `updateDocument` in `useDocuments` hook

**File:** `frontend/src/hooks/useDocuments.ts`

Add an `updateDocument` function that PATCHes the API and applies an optimistic update to local state.

```typescript
const updateDocument = useCallback(async (
  id: string,
  updates: { title?: string | null; summary?: string | null; topics?: string[]; document_date?: string | null }
): Promise<Document> => {
  const res = await apiFetch(`/api/documents/${id}`, {
    method: "PATCH",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(updates),
  })
  if (!res.ok) {
    const err = await res.json().catch(() => ({ detail: "Update failed" }))
    throw new Error(err.detail || "Update failed")
  }
  const updated: Document = await res.json()
  setDocuments(prev => prev.map(d => (d.id === id ? updated : d)))
  return updated
}, [])
```

Return `updateDocument` from the hook.

**Validation:** Hook exported type includes `updateDocument`; TypeScript compiles without error.

---

## Task 4 — Frontend: `EditMetadataModal` component

**File:** `frontend/src/components/documents/EditMetadataModal.tsx` (new file)

Use the existing `Dialog` shadcn component. Fields:

- **Title** — `<Input>` (text), allow clearing to empty string
- **Summary** — `<Textarea>` (multiline), allow clearing
- **Topics** — tag editor: display current tags as removable chips, plus an input that adds a new tag on Enter or comma
- **Document date** — `<Input type="date">` (renders as a date picker natively), allow clearing

State management:
- `localTitle`, `localSummary`, `localTopics`, `localDate` — all initialised from `document` prop on open
- Reset to prop values when `open` changes to `true` (so re-opening reflects current state)
- On Save: call `onSave({ title, summary, topics, document_date })`, show loading state, close on success, show inline error on failure

Props:
```typescript
interface EditMetadataModalProps {
  document: Document | null
  open: boolean
  onClose: () => void
  onSave: (id: string, updates: Partial<Pick<Document, "title" | "summary" | "topics" | "document_date">>) => Promise<void>
}
```

**Validation:** Modal opens, all fields pre-populated from document data, topics can be added/removed, save calls `onSave`, close button dismisses without saving.

---

## Task 5 — Frontend: Wire modal into `DocumentsPanel`

**File:** `frontend/src/components/documents/DocumentsPanel.tsx`

Changes:
1. Add `onUpdate: (id: string, updates: ...) => Promise<void>` prop
2. Add `editingDoc` state: `useState<Document | null>(null)`
3. Add a pencil (edit) icon button in each document card's action row — always visible (not hover-only) like the minus button, placed before the Eye button
4. Render `<EditMetadataModal>` at the bottom of the component, analogous to `<DocumentViewer>`

Use `Pencil` icon from `lucide-react`.

**Validation:** Edit icon appears on every card. Clicking it opens the modal pre-filled with that document's data. Saving updates the card without page reload.

---

## Task 6 — Frontend: Wire `updateDocument` into `DocumentsLayout`

**File:** `frontend/src/components/documents/DocumentsLayout.tsx`

1. Destructure `updateDocument` from `useDocuments()`
2. Pass it as `onUpdate` to `<DocumentsPanel>`

**Validation:** Full end-to-end flow: open modal → edit title → save → card reflects new title immediately.

---

## Gotchas

- The `PATCH` endpoint must use `model_dump(exclude_none=True)` — not `exclude_unset` — because explicitly passing `null` (to clear a field) is valid JSON but `None` in Python, and we want to allow clearing fields.
- Topics is a Postgres `text[]`. The Supabase Python client handles Python `list[str]` → array correctly.
- `document_date` is stored as a plain `date` type in Postgres. Pass ISO strings (`YYYY-MM-DD`) from the frontend. If the user clears the date field, send `null` explicitly to allow clearing it.
- The existing Realtime subscription in `useDocuments` will also receive the PATCH update; ensure it doesn't double-apply. Since `updateDocument` already sets local state, the Realtime event should just overwrite with the same data — no conflict.
- `apiFetch` in the hook already attaches the auth token, so no custom fetch needed.

---

## Definition of Done

- [ ] PATCH endpoint returns updated document with correct field values
- [ ] Unauthenticated PATCH returns 401; wrong user's doc returns 404
- [ ] Edit modal opens from every document card
- [ ] All four fields editable; topics support add/remove
- [ ] Saving updates the card in real-time without reload
- [ ] TypeScript compiles clean (`npm run build` in `/frontend`)
- [ ] Backend starts clean (`uvicorn` no import errors)
