# Module 1: App Shell + Chat + Observability

**Complexity:** ⚠️ Medium — Multiple task groups with interdependencies, but each is well-defined.

## Context

This is the first module of the Agentic RAG Masterclass. No application code exists yet. The user has a local OpenAI-compatible LLM at `http://127.0.0.1:8081/v1`, so we skip the OpenAI Responses API entirely and manage threads/history ourselves from the start. Supabase project needs to be created manually by the user.

## Approach

Build 8 task groups in dependency order: scaffolding → config → database → auth → UI + API (parallel) → integration → observability.

---

## Task Group 1: Project Scaffolding

### 1.1 Backend (Python + FastAPI + venv)
- Create `app/backapp/frontend/` with structure: `app/{main,config,dependencies}.py`, `app/routers/`, `app/models/`, `app/services/`
- Create venv, `requirements.txt` (fastapi, uvicorn, openai, pydantic, pydantic-settings, python-jose, sse-starlette, supabase, langsmith, python-dotenv, httpx)
- **Verify:** `uvicorn app.main:app --port 8000` starts, `GET /health` returns 200

### 1.2 Frontend (Vite + React + TS + Tailwind + shadcn/ui)
- Scaffold with `npm create vite@latest frontend -- --template react-ts`
- Install Tailwind via `@tailwindcss/vite` plugin, configure path aliases (`@/*`)
- Init shadcn/ui, add components: button, input, card, scroll-area, separator, dropdown-menu, dialog, toast
- Install `@supabase/supabase-js`
- Create structure: `src/{components/{ui,auth,chat,layout}, lib, hooks, types}/`
- **Verify:** `npm run dev` starts on :5173 with no errors

### 1.3 Root config files
- `.gitignore` (venv, node_modules, .env, __pycache__, dist)
- `.env.example` with all required vars
- `supabase/migrations/` directory

---

## Task Group 2: Environment Config

### 2.1 Supabase project creation (MANUAL USER STEP)
- User creates Supabase project, copies URL + anon key + service role key + JWT secret
- Disables email confirmation for dev convenience
- Populates `app/backapp/frontend/.env` and `app/frontend/.env`

### 2.2 Backend config module
- `app/backapp/frontend/app/config.py` — Pydantic Settings loading from `.env`
- Fields: supabase_url, supabase_anon_key, supabase_service_role_key, supabase_jwt_secret, llm_base_url, llm_api_key, llm_model, langsmith vars
- **Verify:** `python -c "from app.config import settings; print(settings.llm_base_url)"`

---

## Task Group 3: Database Schema + RLS

### 3.1 SQL migration
- File: `supabase/migrations/001_threads_and_messages.sql`
- **threads** table: id (UUID PK), user_id (FK auth.users), title, created_at, updated_at
- **messages** table: id (UUID PK), thread_id (FK threads CASCADE), user_id (FK auth.users), role (CHECK: user/assistant/system), content, created_at
- Indexes on user_id, thread_id, (thread_id, created_at)
- `updated_at` trigger on threads
- RLS enabled on both tables — SELECT/INSERT/UPDATE/DELETE scoped to `(SELECT auth.uid()) = user_id`
- Messages are append-only (no UPDATE/DELETE policies — cascade from thread delete)
- **Verify:** Run SQL in Supabase dashboard, confirm tables + RLS lock icons visible

---

## Task Group 4: Authentication

### 4.1 Frontend auth
- `src/lib/supabase.ts` — client singleton
- `src/hooks/useAuth.ts` — session state, onAuthStateChange listener, signUp/signIn/signOut
- `src/components/auth/LoginForm.tsx` + `SignUpForm.tsx`
- `src/components/layout/ProtectedRoute.tsx` — redirects unauthenticated users
- `src/App.tsx` — routes: unauthenticated → login/signup, authenticated → chat layout
- **Verify:** Sign up, sign in, refresh (session persists), sign out

### 4.2 Backend JWT verification
- `app/backapp/frontend/app/dependencies.py` — `get_current_user` dependency using `python-jose` to decode Supabase JWT (HS256, audience "authenticated")
- CORS middleware in `main.py` allowing frontend origin
- **Verify:** Curl protected endpoint without token → 401, with valid token → 200

### 4.3 Frontend API client
- `src/lib/api.ts` — `apiFetch(path, options)` wrapper that injects `Authorization: Bearer <token>` from Supabase session
- **Verify:** Network tab shows Authorization header on backend requests

---

## Task Group 5: Chat UI

### 5.1 TypeScript types
- `src/types/index.ts` — Thread and Message interfaces

### 5.2 Thread sidebar + layout
- `src/components/chat/ChatLayout.tsx` — sidebar (left) + message area (right)
- `src/components/chat/ThreadSidebar.tsx` — "New Chat" button, thread list (sorted by updated_at desc), delete button, active highlight
- `src/hooks/useThreads.ts` — threads state, CRUD operations via apiFetch

### 5.3 Message area + input
- `src/components/chat/MessageArea.tsx` — messages display, auto-scroll, streaming indicator, empty state
- `src/components/chat/MessageInput.tsx` — textarea, Enter to send (Shift+Enter for newline), disabled while streaming
- `src/hooks/useChat.ts` — messages state, fetchMessages, sendMessage with SSE stream parsing

### 5.4 Header
- `src/components/layout/Header.tsx` — app title, user email, sign out dropdown

---

## Task Group 6: Chat API (Backend)

### 6.1 Supabase client helper
- `app/backapp/frontend/app/services/supabase.py` — `get_supabase_client(access_token)` that sets user JWT for RLS enforcement

### 6.2 Thread CRUD endpoints
- `app/backapp/frontend/app/routers/threads.py` — GET/POST/PATCH/DELETE `/api/threads`
- `app/backapp/frontend/app/models/threads.py` — Pydantic request/response models
- **Verify:** Curl CRUD operations with valid JWT

### 6.3 Messages endpoint
- `GET /api/threads/{thread_id}/messages` in `app/backapp/frontend/app/routers/chat.py`
- `app/backapp/frontend/app/models/messages.py` — Pydantic models

### 6.4 Chat completions with SSE streaming
- `POST /api/threads/{thread_id}/chat` — core endpoint
- Flow: save user message → fetch history → call LLM with stream=True → stream tokens via SSE → save assistant message
- SSE format: `data: {"token": "..."}` per chunk, `data: {"done": true, "message": {...}}` at end
- Uses `sse-starlette` EventSourceResponse

### 6.5 LLM service
- `app/backapp/frontend/app/services/llm.py` — AsyncOpenAI client pointed at `http://127.0.0.1:8081/v1`, `stream_chat_completion()` async generator
- System prompt: "You are a helpful assistant."
- **Verify:** Standalone test script streams tokens from local LLM

---

## Task Group 7: Frontend-Backend Integration

### 7.1 Wire thread operations
- Connect `useThreads` hook to real backend endpoints
- **Verify:** Create/delete threads, persist across refresh

### 7.2 Wire chat with SSE streaming
- `useChat.sendMessage()` — POST to chat endpoint, parse SSE stream via `fetch` + `ReadableStream.getReader()` (not EventSource, since we need POST)
- **Verify:** Send message → user message appears → assistant streams in → refresh shows both persisted

### 7.3 Auto-title threads
- After first assistant response, backend makes a non-streaming LLM call to generate a short title (3-6 words)
- Updates thread title, frontend refreshes sidebar
- **Verify:** New thread title updates from "New Chat" to something descriptive

---

## Task Group 8: LangSmith Observability

### 8.1 LangSmith integration
- Wrap OpenAI client with `langsmith.wrappers.wrap_openai()`
- Decorate `stream_chat_completion` with `@traceable`
- Env vars: LANGCHAIN_TRACING_V2=true, LANGCHAIN_API_KEY, LANGCHAIN_PROJECT=agentic-rag
- **Verify:** Send message, check LangSmith dashboard — trace appears with inputs/outputs/latency

### 8.2 Trace metadata
- Enrich traces with user_id, thread_id, message_count
- **Verify:** Metadata visible in LangSmith trace details

---

## Key Technical Decisions

| Decision | Choice | Rationale |
|----------|--------|-----------|
| SSE client | `fetch` + ReadableStream | Native `EventSource` only supports GET; we need POST with body |
| RLS approach | User JWT on Supabase client | Automatic RLS enforcement, no manual user_id filtering |
| RLS policy | `(SELECT auth.uid())` | Supabase-recommended perf optimization (caches per query) |
| Messages | Append-only | No edit/delete policies; cascade delete from thread handles cleanup |
| Auth | Supabase JWT verified in backend | Frontend handles login, backend validates token for API access |

## Potential Issues

1. **Supabase Python client JWT setting** — API varies by version, may need adjustment
2. **SSE line splitting** — Chunks may split across reads; need robust parser (or use `@microsoft/fetch-event-source`)
3. **Local LLM model name** — Must match what the server expects; configurable via `LLM_MODEL` env var

## Verification (End-to-End)

1. Start local LLM, backend (`uvicorn`), frontend (`npm run dev`)
2. Open browser → login/signup page appears
3. Sign up with test email → redirected to chat
4. Create thread → appears in sidebar
5. Send message → streams back from local LLM
6. Thread auto-titles after first exchange
7. Refresh → all data persists
8. Check LangSmith → traces visible
9. Sign out → back to login
