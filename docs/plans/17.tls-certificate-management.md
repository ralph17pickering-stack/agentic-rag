# Plan 17: TLS Certificate Management

ðŸ”´ **Complex** â€” Touches infrastructure (Caddy), Docker setup, DB schema, backend API, and a new settings UI.

## Overview

Caddy handles **all** TLS termination. The backend stays on plain HTTP inside the Docker network. A Settings UI lets the operator configure hostnames and view certificate status.

## Architecture

```
Internet
  â”‚  HTTPS (Let's Encrypt, or self-signed on localhost)
  â–¼
Caddy (port 443/80)
  â”œâ”€â”€ /* â†’ serves React build (static files from multi-stage build)
  â””â”€â”€ /api/* â†’ reverse-proxy â†’ http://backend:8001 (plain HTTP, Docker network)

Backend (FastAPI / uvicorn)
  â””â”€â”€ HTTP on port 8001 (internal only, not exposed to host)

Frontend (built React)
  â””â”€â”€ Same-origin requests to /api/* (no CORS needed in production)
```

**Key decisions:**
- Backend runs **plain HTTP only** â€” no self-signed certs, no uvicorn SSL. Caddy terminates TLS for everything.
- In production, Caddy auto-provisions Let's Encrypt certs for the public hostname.
- On `localhost`, Caddy auto-generates a self-signed cert (ACME can't work without a routable domain).
- Frontend and API are same-origin behind Caddy, so CORS is only needed for local dev (Vite dev server on :5173).
- Settings writes are restricted to service_role (admin) â€” the backend uses the service role client for mutations.

---

## Sub-Plan A: Infrastructure (Docker + Caddy)

### Task A1: Create backend Dockerfile
**File**: `app/backapp/frontend/Dockerfile`

```dockerfile
FROM python:3.12-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

EXPOSE 8001

CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8001"]
```

Notes:
- No `--reload` in production image.
- `.dockerignore` should exclude `venv/`, `__pycache__/`, `.env`.

**Validation**: `docker build -t agentic-rag-backend ./backend` succeeds.

### Task A2: Create frontend multi-stage Dockerfile
**File**: `app/frontend/Dockerfile`

```dockerfile
FROM node:22-alpine AS build

WORKDIR /app
COPY package.json package-lock.json ./
RUN npm ci
COPY . .

# Build args become VITE_ env vars at build time
ARG VITE_SUPABASE_URL
ARG VITE_SUPABASE_ANON_KEY
ARG VITE_API_URL

RUN npm run build

# Output stage â€” just the dist/ folder, no runtime
FROM scratch AS dist
COPY --from=build /app/dist /dist
```

The final `dist/` is copied into a named volume that Caddy serves. The `scratch` stage means the image has zero runtime footprint â€” it's only used to produce the build artifact.

**Validation**: `docker build -t agentic-rag-frontend ./frontend` succeeds; the image contains `/dist/index.html`.

### Task A3: Create docker-compose.yml
**File**: `docker-compose.yml` (project root)

```yaml
services:
  backend:
    build: ./backend
    env_file: ./app/backapp/frontend/.env
    networks:
      - app
    # Not exposed to host â€” only reachable via Caddy
    expose:
      - "8001"
    restart: unless-stopped

  frontend:
    build:
      context: ./frontend
      args:
        VITE_SUPABASE_URL: ${VITE_SUPABASE_URL}
        VITE_SUPABASE_ANON_KEY: ${VITE_SUPABASE_ANON_KEY}
        VITE_API_URL: ""  # Same-origin via Caddy, no explicit URL needed
    # Build-only service â€” no runtime container
    profiles: ["build"]

  caddy:
    image: caddy:2-alpine
    ports:
      - "80:80"
      - "443:443"
      - "443:443/udp"  # HTTP/3
    environment:
      - PUBLIC_HOSTNAME=${PUBLIC_HOSTNAME:-localhost}
    volumes:
      - ./caddy/Caddyfile:/etc/caddy/Caddyfile:ro
      - caddy_data:/data          # Persistent cert storage
      - caddy_config:/config
      - frontend_dist:/srv/frontend:ro
    depends_on:
      - backend
    networks:
      - app
    restart: unless-stopped

volumes:
  caddy_data:
  caddy_config:
  frontend_dist:
    # Populated by: docker compose run --rm frontend
    # Or by copying build output: docker cp frontend_build:/dist/. frontend_dist_volume

networks:
  app:
```

Note: The frontend build artifact needs to be copied into the `frontend_dist` volume. Add a helper script (Task A5) for this.

**Validation**: `docker compose config` passes without errors.

### Task A4: Create Caddyfile
**File**: `caddy/Caddyfile`

```caddyfile
{$PUBLIC_HOSTNAME} {
    # SPA: try file, then fallback to index.html for client-side routing
    root * /srv/frontend
    try_files {path} /index.html
    file_server

    # Proxy API to backend (plain HTTP on Docker network)
    handle /api/* {
        reverse_proxy backend:8001
    }

    # Health check passthrough
    handle /health {
        reverse_proxy backend:8001
    }
}
```

Key points:
- `{$PUBLIC_HOSTNAME}` is replaced by the env var passed in docker-compose.
- When `PUBLIC_HOSTNAME=localhost`, Caddy uses a self-signed cert (no ACME).
- `try_files` before `file_server` ensures SPA client-side routing works.
- `/api/*` and `/health` are proxied to backend; everything else serves the React build.

**Validation**: `docker compose run --rm caddy caddy validate --config /etc/caddy/Caddyfile` passes.

### Task A5: Build helper script
**File**: `scripts/build-and-deploy.sh`

```bash
#!/bin/bash
set -euo pipefail

echo "Building frontend..."
docker compose build frontend

echo "Copying frontend dist to volume..."
# Create a temp container from the frontend image, copy dist out
docker compose run --rm --no-deps -v frontend_dist:/out frontend sh -c "cp -r /dist/* /out/"

echo "Building backend..."
docker compose build backend

echo "Starting services..."
docker compose up -d caddy backend

echo "Done! Site available at https://${PUBLIC_HOSTNAME:-localhost}"
```

**Validation**: Script runs end-to-end; `curl -k https://localhost/health` returns `{"status": "ok"}`.

### Task A6: Create .dockerignore files
**Files**: `app/backapp/frontend/.dockerignore`, `app/frontend/.dockerignore`

app/backapp/frontend/.dockerignore:
```
venv/
__pycache__/
*.pyc
.env
certs/
```

app/frontend/.dockerignore:
```
node_modules/
dist/
.env
```

**Validation**: Docker builds don't include ignored files (build context size is small).

---

## Sub-Plan B: Backend CORS Update

### Task B1: Make CORS origins configurable
**File**: `app/backapp/frontend/app/config.py`

Add to `Settings`:
```python
cors_origins: str = "http://localhost:5173,http://127.0.0.1:5173"
```

**File**: `app/backapp/frontend/app/main.py`

Replace hardcoded CORS origins:
```python
app.add_middleware(
    CORSMiddleware,
    allow_origins=[o.strip() for o in settings.cors_origins.split(",") if o.strip()],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)
```

Rationale: Behind Caddy, frontend requests to `/api/*` are same-origin (no CORS needed). But for local dev with `npm run dev` on :5173, CORS is still required. Making it configurable means the Docker deployment can set `CORS_ORIGINS=""` (empty = no CORS) while dev keeps the current behavior.

**Validation**: Backend starts with default origins; setting `CORS_ORIGINS=https://example.com` in `.env` changes the allowed origins.

---

## Sub-Plan C: Settings DB + Backend API

### Task C1: Database migration 016 â€” settings table
**File**: `supabase/migrations/016_settings.sql`

```sql
CREATE TABLE IF NOT EXISTS settings (
    key        TEXT PRIMARY KEY,
    value      TEXT NOT NULL,
    updated_at TIMESTAMPTZ DEFAULT now()
);

-- RLS: authenticated users can read; only service_role can write
ALTER TABLE settings ENABLE ROW LEVEL SECURITY;
CREATE POLICY "anyone can read settings"
    ON settings FOR SELECT TO authenticated USING (true);
CREATE POLICY "service role writes settings"
    ON settings FOR ALL TO service_role USING (true);

-- Auto-update timestamp
CREATE OR REPLACE FUNCTION update_settings_timestamp()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = now();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER settings_updated_at
    BEFORE UPDATE ON settings
    FOR EACH ROW EXECUTE FUNCTION update_settings_timestamp();

-- Seed defaults
INSERT INTO settings (key, value) VALUES
    ('public_hostname', 'localhost'),
    ('tls_enabled', 'false'),
    ('cert_expires_at', ''),
    ('cert_issuer', ''),
    ('cert_subject', '')
ON CONFLICT DO NOTHING;
```

Changes from original:
- Removed `backend_internal_hostname` â€” not needed since backend is always plain HTTP behind Caddy.
- Added `updated_at` trigger for automatic timestamp management.
- Added `cert_issuer` field (useful to distinguish Let's Encrypt vs self-signed).
- Default `public_hostname` is `localhost` instead of empty string.

**Validation**: Migration applies without errors; `SELECT * FROM settings` returns 5 rows.

### Task C2: Settings Pydantic models
**File**: `app/backapp/frontend/app/models/settings.py`

```python
from pydantic import BaseModel


class AppSettings(BaseModel):
    """Current application settings from the DB."""
    public_hostname: str
    tls_enabled: bool
    cert_expires_at: str
    cert_issuer: str
    cert_subject: str


class UpdateSettingsRequest(BaseModel):
    """Partial update â€” only provided fields are written."""
    public_hostname: str | None = None
    tls_enabled: bool | None = None
```

Notes:
- `cert_*` fields are read-only from the API perspective â€” they're populated by the cert-info endpoint.
- `UpdateSettingsRequest` only exposes fields the operator should change. Cert metadata is derived, not user-set.

**Validation**: Models import without errors.

### Task C3: Settings router
**File**: `app/backapp/frontend/app/routers/settings.py`

```python
import ssl
import subprocess
from datetime import datetime, timezone
from fastapi import APIRouter, Depends, HTTPException
from app.auth import get_current_user
from app.services.supabase import get_service_supabase_client
from app.models.settings import AppSettings, UpdateSettingsRequest
from app.config import settings as app_config

router = APIRouter(prefix="/api/settings", tags=["settings"])


@router.get("", response_model=AppSettings)
async def get_settings(user=Depends(get_current_user)):
    """Return all settings as a dict."""
    sb = get_service_supabase_client()
    rows = sb.table("settings").select("key, value").execute()
    data = {r["key"]: r["value"] for r in rows.data}
    return AppSettings(
        public_hostname=data.get("public_hostname", "localhost"),
        tls_enabled=data.get("tls_enabled", "false").lower() == "true",
        cert_expires_at=data.get("cert_expires_at", ""),
        cert_issuer=data.get("cert_issuer", ""),
        cert_subject=data.get("cert_subject", ""),
    )


@router.put("")
async def update_settings(
    body: UpdateSettingsRequest,
    user=Depends(get_current_user),
):
    """Update one or more settings. Uses service_role to bypass RLS."""
    sb = get_service_supabase_client()
    updates = body.model_dump(exclude_none=True)
    if not updates:
        raise HTTPException(400, "No fields to update")
    for key, value in updates.items():
        sb.table("settings").upsert(
            {"key": key, "value": str(value)},
            on_conflict="key",
        ).execute()
    return {"updated": list(updates.keys())}


@router.get("/cert-info")
async def get_cert_info(user=Depends(get_current_user)):
    """Read live cert info from the public hostname via SSL handshake."""
    sb = get_service_supabase_client()
    hostname_row = sb.table("settings").select("value").eq("key", "public_hostname").single().execute()
    hostname = hostname_row.data["value"] if hostname_row.data else "localhost"

    try:
        cert = ssl.get_server_certificate((hostname, 443))
        # Parse with openssl for subject/expiry
        proc = subprocess.run(
            ["openssl", "x509", "-noout", "-subject", "-issuer", "-enddate"],
            input=cert, capture_output=True, text=True, timeout=5,
        )
        lines = proc.stdout.strip().split("\n")
        info = {}
        for line in lines:
            if line.startswith("subject="):
                info["cert_subject"] = line.split("=", 1)[1].strip()
            elif line.startswith("issuer="):
                info["cert_issuer"] = line.split("=", 1)[1].strip()
            elif line.startswith("notAfter="):
                info["cert_expires_at"] = line.split("=", 1)[1].strip()

        # Persist cert metadata back to settings
        for key, value in info.items():
            sb.table("settings").upsert(
                {"key": key, "value": value}, on_conflict="key"
            ).execute()

        return info
    except Exception as e:
        raise HTTPException(502, f"Could not read cert from {hostname}:443 â€” {e}")
```

Key differences from original:
- **No `regenerate-cert` endpoint** â€” Caddy manages certs automatically. There's nothing to regenerate manually.
- **`cert-info` reads live cert** via SSL handshake to the public hostname, rather than reading a file. This works whether Caddy uses Let's Encrypt or self-signed.
- Uses `get_service_supabase_client()` for all DB writes (bypasses RLS).
- All endpoints require authentication via `get_current_user`.

**Validation**: `curl -H "Authorization: Bearer <jwt>" http://localhost:8001/api/settings` returns settings JSON.

### Task C4: Register settings router in main.py
**File**: `app/backapp/frontend/app/main.py`

Add import and registration:
```python
from app.routers import threads, chat, documents, settings
# ...
app.include_router(settings.router)
```

**Validation**: `/api/settings` appears in FastAPI auto-docs at `/docs`.

---

## Sub-Plan D: Frontend Settings UI

### Task D1: Add "settings" view to App.tsx
**File**: `app/frontend/src/App.tsx`

Update the `View` type and render logic:
```typescript
type View = "chat" | "documents" | "settings"

// In the return:
{view === "chat" ? (
  <ChatLayout breakpoint={breakpoint} />
) : view === "documents" ? (
  <DocumentsLayout />
) : (
  <SettingsPage />
)}
```

Import `SettingsPage` from `@/components/settings/SettingsPage`.

**Validation**: Switching to settings view renders the SettingsPage component.

### Task D2: Add Settings navigation to Header
**File**: `app/frontend/src/components/layout/Header.tsx`

Add a Settings nav button (using `Settings` icon from lucide-react) in the desktop nav alongside Chat and Documents:
```tsx
import { Settings } from "lucide-react"

// In the nav section:
<Button
  variant={view === "settings" ? "secondary" : "ghost"}
  size="sm"
  onClick={() => onViewChange("settings")}
>
  <Settings className="h-4 w-4 mr-1" />
  Settings
</Button>
```

Also add to the mobile dropdown menu.

Update the `View` type in Header.tsx to match: `type View = "chat" | "documents" | "settings"`

**Validation**: Settings button appears in header; clicking it switches to settings view.

### Task D3: useSettings hook
**File**: `app/frontend/src/hooks/useSettings.ts`

```typescript
import { useState, useEffect, useCallback } from "react"
import { supabase } from "@/lib/supabase"

interface AppSettings {
  public_hostname: string
  tls_enabled: boolean
  cert_expires_at: string
  cert_issuer: string
  cert_subject: string
}

const API_URL = import.meta.env.VITE_API_URL || ""

export function useSettings() {
  const [settings, setSettings] = useState<AppSettings | null>(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)

  const fetchSettings = useCallback(async () => {
    setLoading(true)
    setError(null)
    try {
      const { data: { session } } = await supabase.auth.getSession()
      const res = await fetch(`${API_URL}/api/settings`, {
        headers: { Authorization: `Bearer ${session?.access_token}` },
      })
      if (!res.ok) throw new Error(`${res.status} ${res.statusText}`)
      setSettings(await res.json())
    } catch (e: any) {
      setError(e.message)
    } finally {
      setLoading(false)
    }
  }, [])

  const updateSetting = useCallback(async (key: string, value: string | boolean) => {
    const { data: { session } } = await supabase.auth.getSession()
    const res = await fetch(`${API_URL}/api/settings`, {
      method: "PUT",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${session?.access_token}`,
      },
      body: JSON.stringify({ [key]: value }),
    })
    if (!res.ok) throw new Error(`${res.status} ${res.statusText}`)
    await fetchSettings()  // Refresh after update
  }, [fetchSettings])

  const refreshCertInfo = useCallback(async () => {
    const { data: { session } } = await supabase.auth.getSession()
    const res = await fetch(`${API_URL}/api/settings/cert-info`, {
      headers: { Authorization: `Bearer ${session?.access_token}` },
    })
    if (!res.ok) throw new Error(`${res.status} ${res.statusText}`)
    await fetchSettings()  // Refresh to show updated cert info
    return await res.json()
  }, [fetchSettings])

  useEffect(() => { fetchSettings() }, [fetchSettings])

  return { settings, loading, error, updateSetting, refreshCertInfo }
}
```

**Validation**: Hook fetches settings on mount; `updateSetting` persists changes.

### Task D4: SettingsPage component
**File**: `app/frontend/src/components/settings/SettingsPage.tsx`

Uses shadcn/ui components: `Card`, `CardHeader`, `CardTitle`, `CardContent`, `Input`, `Button`, `Label`, `Badge`.

Layout â€” single scrollable page with two cards:

**Card 1: Hostname Configuration**
- `public_hostname` text input + Save button
- Helper text: "The public domain Caddy uses for TLS. Set to `localhost` for local dev."

**Card 2: TLS Certificate**
- Read-only display of: cert subject, cert issuer, expiry date
- Status badge: "Valid" (green) / "Expiring Soon" (yellow, < 30 days) / "Expired" (red) / "Unknown" (gray, no cert info)
- "Refresh Cert Info" button (calls `refreshCertInfo()` from hook)
- Helper text: "Caddy manages certificates automatically. Use Refresh to check current cert status."

No "Regenerate Certificate" button â€” Caddy handles renewal automatically. The UI is informational + hostname config only.

```typescript
// Cert status logic:
function certStatus(expiresAt: string): "valid" | "expiring" | "expired" | "unknown" {
  if (!expiresAt) return "unknown"
  const expiry = new Date(expiresAt)
  const now = new Date()
  const daysLeft = (expiry.getTime() - now.getTime()) / (1000 * 60 * 60 * 24)
  if (daysLeft < 0) return "expired"
  if (daysLeft < 30) return "expiring"
  return "valid"
}
```

**Validation**: Settings page displays hostname input and cert info card. Save persists hostname. Refresh updates cert info.

---

## Sub-Plan E: Environment & Config

### Task E1: Update backend config.py
**File**: `app/backapp/frontend/app/config.py`

Add to `Settings` class:
```python
public_hostname: str = "localhost"
cors_origins: str = "http://localhost:5173,http://127.0.0.1:5173"
```

### Task E2: Update .env.EXAMPLE files

**File**: `app/backapp/frontend/.env.EXAMPLE` â€” append:
```
# Deployment
PUBLIC_HOSTNAME=localhost
CORS_ORIGINS=http://localhost:5173,http://127.0.0.1:5173
```

**File**: `app/frontend/.env.EXAMPLE` â€” no changes needed (VITE_API_URL is already there; it stays empty when behind Caddy).

### Task E3: Create project-root .env.EXAMPLE
**File**: `.env.EXAMPLE` (project root, for docker-compose)

```
# Used by docker-compose for Caddy
PUBLIC_HOSTNAME=localhost

# Passed as build args for frontend
VITE_SUPABASE_URL=http://localhost:8000
VITE_SUPABASE_ANON_KEY=your-anon-key-here
```

### Task E4: Add caddy/ and scripts/ to .gitignore exclusions
Ensure `caddy/Caddyfile` is tracked but `caddy/data/` and `caddy/config/` are not (they're Docker volumes, but just in case).

**File**: `.gitignore` â€” append:
```
# Caddy persistent data (managed by Docker volumes)
caddy/data/
caddy/config/
```

**Validation**: All example files present; `git status` shows new files as expected.

---

## Execution Order

1. **Sub-Plan E** (Config) â€” add env vars to config.py and .env.EXAMPLE first, since other tasks depend on them
2. **Sub-Plan B** (CORS) â€” make CORS configurable before Docker changes
3. **Sub-Plan A** (Infrastructure) â€” Dockerfiles, docker-compose, Caddyfile, build script
4. **Sub-Plan C** (Settings DB + API) â€” migration, models, router
5. **Sub-Plan D** (Frontend UI) â€” settings page, hook, navigation

## Validation Checklist

- [ ] `docker compose config` passes without errors
- [ ] `docker compose build` succeeds for both backend and frontend
- [ ] `docker compose up -d` starts Caddy + backend
- [ ] `curl -k https://localhost/health` returns `{"status": "ok"}`
- [ ] `curl -k https://localhost/` returns the React SPA HTML
- [ ] Client-side routes (e.g., `https://localhost/` after navigating to docs) work via `try_files` fallback
- [ ] Settings API returns current settings (authenticated)
- [ ] Settings update persists in DB
- [ ] Cert info endpoint returns cert metadata from live SSL handshake
- [ ] Frontend Settings page displays hostname and cert info
- [ ] Settings save button persists hostname change
- [ ] CORS still works for local dev (`npm run dev` on :5173 â†’ backend on :8001)

## Gotchas

- Let's Encrypt requires a publicly routable hostname; for local dev, `PUBLIC_HOSTNAME=localhost` makes Caddy use a self-signed cert automatically.
- `caddy:2-alpine` needs persistent data volume for cert storage â€” losing it means re-provisioning certs on restart.
- Docker internal network: service name `backend` resolves inside the compose network. Caddy's `reverse_proxy backend:8001` uses HTTP by default.
- Frontend build args (`ARG` in Dockerfile) are baked in at build time â€” changing Supabase URL requires rebuilding the frontend image.
- `ssl.get_server_certificate()` in the cert-info endpoint needs the backend container to reach the public hostname. In Docker, this means the Caddy container must be reachable by hostname from the backend container (both on `app` network, use service name `caddy` or the actual hostname).
- The `openssl` CLI must be available in the backend Docker image. `python:3.12-slim` includes it via libssl, but the `openssl` binary may need explicit install: `RUN apt-get update && apt-get install -y openssl && rm -rf /var/lib/apt/lists/*`.
